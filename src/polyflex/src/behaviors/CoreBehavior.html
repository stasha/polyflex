<script>
	(function (window, document) {

		"use strict";
		var polyflex = window.polyflex = window.polyflex || {};
		var behaviors = polyflex.behaviors = polyflex.behaviors || {};
		var Event = polyflex.Event;
		var Channel = polyflex.Channel;
		window.lastScrollPosition = window.scrollPosition = window.scrollPosition || {x: 0, y: 0};
		polyflex.preventWindowScrolling = polyflex.preventWindowScrolling || [];
		/**
		 * Behavior containing core functionality.
		 * 
		 * @type type
		 */
		behaviors.CoreBehaviorImpl = {
			customElements: [],
			isDetached: null,
			webComponentsReady: null,
			skipScrollToAnimation: false,
			skipWindowScrollToPosition: false,
			properties: {
				debug: {
					type: Boolean,
					value: false
				}
			},
			ready: function () {
				this.dispatchEvent(new CustomEvent("child-ready", {bubbles: true, cancelable: true}));
			},
			attached: function () {
				this.isDetached = false;
				this.dispatchEvent(new CustomEvent("child-added", {bubbles: true, cancelable: true}));
				this.customElements.push(this);
				this.cuid = Math.random().toString().replace(".", "");
			},
			detached: function () {
				this.isDetached = true;
				this.customElements.splice(this.customElements.indexOf(this), 1);
				if (this._lightParent) {
					this._lightParent.dispatchEvent(new CustomEvent("child-removed", {bubbles: true, cancelable: true}));
				}
			},
			/**
			 * Returns true/false if component is in debug mode.
			 * 
			 * @returns {Boolean}
			 */
			get isInDebugMode() {
				return document.getElementsByTagName("html")[0].className.indexOf("debug") > -1;
			},
			/**
			 * Invoked when this comonent is ready.
			 * 
			 * @returns {undefined}
			 */
			created: function () {
				this.isDetached = true;
				try {
					this.one(window, Event.WEB_COMPONENTS_READY, this.componentsReady);
				} catch (e) {
					console.warn("You should implement EventBehavior behavior in this component.");
				}

				var cv = document.querySelector(".body");
				var self = this;
				self.enableBodyScroll = function (e) {
					var pos = self.bodyScrollPosition;
					self.body.classList.remove("non-scrollable-viewport");
					cv.classList.remove("scrollable-viewport");
					TweenMax.set(window, {scrollTo: {x: pos.x, y: pos.y}});
					self.bodyIsScrolling = true;
					window.scrollPosition.ignoreAnchors = false;
				};
				self.debounceDisable = function (delay, position) {
					var pos = position || window.lastScrollPosition;
					self.disableBodyScroll(pos);
					TweenMax.set(cv, {scrollTo: {x: pos.x, y: pos.y}});
					self.debounce('DEBOUNCE-DISABLE', function () {
						self.disableBodyScroll(pos);
						TweenMax.set(cv, {scrollTo: {x: pos.x, y: pos.y}});
					}, delay);
				};
				self.disableBodyScroll = function (position) {
					if (self.body.className.indexOf("non-scrollable-viewport") === -1) {
						//self.scrollFromPopState = true;
						var pos = position || window.lastScrollPosition;
						self.body.classList.add("non-scrollable-viewport");
						cv.classList.add("scrollable-viewport");
						TweenMax.set(cv, {scrollTo: {x: pos.x, y: pos.y}});
						self.bodyIsScrolling = false;
					}
				};
			},
			/**
			 * Invoked when all webcomponents are ready.
			 * 
			 * @returns {undefined}
			 */
			componentsReady: function () {
				this.webComponentsReady = true;
				console.log("webcomponents ready");
			},
			/**
			 * Returns body element
			 * 
			 * @returns {Element}
			 */
			get body() {
				return document.body;
			},
			get base() {
				return document.querySelector("polyflex-base");
			},
			getOffset: function (elm, againstElm) {
				var bdy = againstElm || document.querySelector(".body");
				var bodyRect = bdy.getBoundingClientRect(),
						elemRect = elm.getBoundingClientRect(),
						top = -bdy.scrollTop - (elemRect.top - bodyRect.top),
						left = -bdy.scrollLeft - (elemRect.left - bodyRect.left);
				return {x: left, y: top};
			},
			getOffsetWithoutScrollOffset: function (elm, againstElm) {
				var offset = this.getOffset(elm, againstElm);
				offset.x = Math.abs(offset.x);
				offset.y = Math.abs(offset.y);
				return offset;
			},
			getComputedStyle: function (elm) {
				var style = elm.currentStyle || window.getComputedStyle(elm);
				return style;
			},
			getElementFromHash: function (context) {
				var elm;
				var ctx = context || (this.routeContext && this.routeContext.currentRoute && this.routeContext.currentRoute.context);
				if (!ctx) {
					ctx = this.currentRoute && this.currentRoute.context;
				}
				if (ctx) {
					try {
						elm = document.querySelector("#" + ctx.hash) || document.querySelector('[name="' + ctx.hash + '"');
					} catch (err) {
						// non supported selector
					}
				}
				return elm;
			},
			/**
			 * Returns if this element is displayed in th DOM or not.
			 * 
			 * @returns {Boolean}
			 */
			get isDisplayed() {
				var elm = this.arguments[0] || this;
				while (elm.tagName !== 'BODY') {
					if (elm.style.display === "none") {
						return false;
					}
					elm = elm.parentNode;
				}
				return true;
			},
			setWindowScrollObject: function (data) {
				window.scrollPosition = extend(window.scrollPosition || {}, data);
			},
			get windowScrollPosition() {
				var pos = {};
				if (window.pageYOffset !== undefined) {
					pos.x = window.pageXOffset;
					pos.y = window.pageYOffset;
				} else {
					var de = document.documentElement, b = document.body;
					pos.x = de.scrollLeft || b.scrollLeft || 0;
					pos.y = de.scrollTop || b.scrollTop || 0;
				}
				return pos;
			},
			set windowScrollPosition(obj) {

				this.disableBodyScroll();
				//prevent scrolling untill preventScrolling property is not deleted
				if (polyflex.preventWindowScrolling.length > 0) {
					return;
				}

				var self = this;
				if (this.skipWindowScrollToPosition) {
					this.skipWindowScrollToPosition = false;
					return;
				}
				this.debounce('SCROLL-TO-DELAY', function () {
					this.cancelSavingScrollPosition();
					// Emitting window scroll mesage so interested parties can 
					// prevent window from scrolling and pospon it to desired
					// moment.
					this.sendMessage({channel: Channel.WINDOW_SCROLL});
					//prevent window scrolling untill preventWindowScrolling property is not deleted
					if (polyflex.preventWindowScrolling.length > 0) {
						return;
					}
					if (obj) {

						if (typeof obj.getAttribute === "function") {
							obj = this.getOffsetWithoutScrollOffset(obj);
						}

						if (this.base && this.base.enableScrollToAnimation) {
							// applyes new position to window
							this.debounce("SCROLL-WINDOW", function () {

								this.cancelSavingScrollPosition();
								var cv = document.querySelector(".body");
								if (!this.skipScrollToAnimation && !this.scrollFromPopState) {

									// window last scroll position
									var wlsp = window.lastScrollPosition;
									// window current scroll position
									var wcsp = self.bodyScrollPosition;
									// prevent scrolling if current scroll position and destination position
									if (obj.x === wcsp.x && obj.y === wcsp.y) {
										self.enableBodyScroll();
										return;
									}

									// prevent scrolling if last scroll position is not equal to current scroll position
									if ((wlsp.x !== wcsp.x && wcsp.maxScrollX !== 0) || (wlsp.y !== wcsp.y && wcsp.maxScrollY !== 0)) {
										self.enableBodyScroll();
										return;
									}

									// scroll window to desired position
									window.scrollToEffect = TweenMax.to(cv, this.base.scrollToAnimationSpeed, {scrollTo: {x: obj.x, y: obj.y, autoKill: true}, ease: Power2.easeOut, onComplete: function () {
											self.debounce('ENABLE-BODY-SCROLL', function () {
												self.enableBodyScroll();
												window.lastScrollPosition = self.bodyScrollPosition;
												if(self.router){
													self.router.saveScrollPosition();
												}
											}, 5);
										}});
								} else {
									TweenMax.set(window, {scrollTo: {x: obj.x, y: obj.y}});
								}
								this.skipScrollToAnimation = false;
							}, 5);
						} else {
							this.debounce("SCROLL-WINDOW", function () {
								TweenMax.set(window, {scrollTo: {x: obj.x, y: obj.y}});
								this.skipScrollToAnimation = false;
							}, 5);
						}
					}
				}, 100);
			},
			get fakeBodyScrollPosition() {
				var fb = document.querySelector(".body");
				return extend({}, window.scrollPosition, {x: fb.scrollLeft, y: fb.scrollTop});
			},
			get bodyScrollPosition() {
				var wsp = this.windowScrollPosition;
				var fbs = this.fakeBodyScrollPosition;
				var fb;
				if (wsp.x === 0 && wsp.y === 0 && (fbs.x > 0 || fbs.y > 0)) {
					fb = this.fakeBody;
					return extend({}, wsp, fbs, {maxScrollX: fb.scrollWidth - fb.clientWidth, maxScrollY: fb.scrollHeight - fb.clientHeight});
				}

				fb = this.body;
				return extend({}, fbs, wsp, {maxScrollX: fb.scrollWidth - fb.clientWidth, maxScrollY: fb.scrollHeight - fb.clientHeight});
			},
			updateWindowScrollPosition: function () {
				this.cancelSavingScrollPosition();
				this.disableBodyScroll();
				var elm;
				if (!window.scrollPosition.ignoreAnchors) {
					elm = this.getElementFromHash();
					window.scrollPosition.ignoreAnchors = false;
				}
				this.windowScrollPosition = (elm && this.getOffsetWithoutScrollOffset(elm)) || window.scrollPosition;
			},
			cancelSavingScrollPosition: function () {
				this.cancelDebouncer('SAVE-SCROLL-POSITION-IN-STATE');
			},
			addWindowScrollBlocker: function (name) {
				polyflex.preventWindowScrolling.push(name || this.cuid);
			},
			removeWindowScrollBlocker: function (name) {
				var index = polyflex.preventWindowScrolling.indexOf(name || this.cuid);
				if (index > -1) {
					polyflex.preventWindowScrolling.splice(index, 1);
				}
			},
			get polyflex() {
				return window.polyflex;
			},
			get channels() {
				return this.polyflex.channels;
			},
			get events() {
				return this.polyflex.events;
			},
			get urls() {
				return this.polyflex.urls;
			},
			get fakeBody() {
				return document.querySelector(".body");
			},
			get router(){
				return document.querySelector("url-router");
			},
			/**
			 * Looks up for an object based on passed string path.
			 * Path example: "foo.bar.baz".
			 * 
			 * @param {String} path
			 * @param {Object} object - Object from where to start lookup. 
			 * If no object is specified, than lookup starts from window object.
			 * 
			 * @returns {Object}
			 */
			pathToObject: function (path, object) {
				// if object is not defined, than we start 
				// to bild a path from window object;
				var obj = object || window;
				var stack = path.split('.');
				while (stack.length > 0) {
					obj = obj[stack.shift()];
					if (!obj) {
						return null;
					}
				}

				return obj;
			},
			/**
			 * Logs messages if debug is set to true.
			 * 
			 * @param {type} arg
			 * @returns {undefined}
			 */
			log: function (arg) {
				if (this.debug || this.isInDebugMode) {
					console.log(arg);
				}
			},
			/**
			 * Converts string to array based on space or coma separator.
			 * 
			 * @param {type} str
			 * @returns {Array}
			 */
			stringToArray: function (str) {
				if (!str) {
					return [];
				}
				var normalizedStr = str.toString().replace(/,/g, " ");
				normalizedStr = normalizedStr.replace(/\s+/g, " ");
				var strArr = normalizedStr.split(" ");
				return strArr;
			},
			/**
			 * Prevents default behavior.
			 * 
			 * @param {type} e
			 * @returns {undefined}
			 */
			preventDefault: function (e) {
				if (e.currentTarget.customElement) {
					e.currentTarget.customElement.log("Preventing default behavior.");
				}
				e.preventDefault();
			}
		};

		behaviors.CoreBehavior = [behaviors.CoreBehaviorImpl];

	})(window, document);

</script>