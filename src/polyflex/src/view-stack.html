<link rel="import" href="behaviors/CoreBehavior.html" />
<link rel="import" href="behaviors/EventBehavior.html" />
<link rel="import" href="behaviors/RoutingBehavior.html" />

<dom-module id="view-stack">
	<style>
		:host {
			position: relative;
			overflow: hidden;
			display: block;
		}
		:host ::content > * {
			position: absolute;
			display: none;
		}

		:host ::content > *.selected {
			/*position: relative;*/
		}

	</style>
	<template>
		<content></content>
	</template>

	<script>

		(function (window, Channel) {

			"use strict";

			var polyflex = window.polyflex = window.polyflex || {};
			var behaviors = polyflex.behaviors = polyflex.behaviors || {};
			var _routes = polyflex._routes;
			var Route = polyflex.Route;
			var Event = polyflex.Event;


			Polymer({
				is: "view-stack",
				behaviors: [behaviors.EventBehavior, behaviors.RoutingBehavior],
				extend: "div",
				items: null,
				routeContext: null,
				_itemIsLoading: false,
				_lastSelectedIndex: 0,
				_resizeEffect: null,
				_showEffect: null,
				_hideEffect: null,
				_urls: [],
				properties: {
					selectedIndex: {
						type: Number,
						value: 0,
						observer: "indexChanged"
					},
					resizeToContent: {
						type: Boolean,
						value: false,
						reflectToAttribute: true
					},
					showEffect: {
						type: String,
						observer: "setShowEffect"
					},
					hideEffect: {
						type: String,
						observer: "setHideEffect"
					}
				},
				setShowEffect: function (newValue) {
					this._showEffect = newValue && document.querySelector(newValue).clone();
				},
				setHideEffect: function (newValue) {
					this._hideEffect = newValue && document.querySelector(newValue).clone();
				},
				get showEffect() {
					return this._showEffect;
				},
				get hideEffect() {
					return this._hideEffect;
				},
				get lastSelectedIndex() {
					return this._lastSelectedIndex;
				},
				update: function () {
					var self = this;
					if (this.isRemoved) {
						return;
					}

					this._urls = [];
					this.items = this.querySelectorAll("view-stack > *");

					for (var i = 0; i < this.items.length; ++i) {
						var item = this.items[i];
						item.index = i;
						item.name = i;
						var he = this._hideEffect.clone();
						var inSpeed = he.speed;
						he.speed = 0;
						he.start(item, this, null, null, function () {
							he.speed = inSpeed;
						});

						this.setUrlRouting(item);
					}
				},
				setUrlRouting: function (item) {
					var url = item.getAttribute("route");
					if (url) {

						this._urls[url] = this._urls[url] || [];
						this._urls[url].push(item.index);

						item.preventInvokingRequestOnEnteringRoute = true;
						var self = this;
						this.onMessage({
							channel: Channel.ROUTE_ENTER,
							route: url,
							callback: function (context) {
								self.enteringItemRoute(context, item);
							}
						});

						this.router.addRoute(url);
					}

					var exitRoute = item.getAttribute("exit-route");
					if (exitRoute) {
						this.onMessage({
							channel: Channel.ROUTE_EXIT,
							route: exitRoute,
							callback: function (context) {
								self.exitingItemRoute(context, item);
							}
						});
					}
				},
				enteringItemRoute: function (context, item, ignoreSameUrl) {
					var url = item.getAttribute("route");
					item.indexCounter = item.indexCounter || item.index;

					if (ignoreSameUrl === false && this.routeContext && this.routeContext.path === context.path) {
						return;
					}
					this.routeContext = context;
					var urlLength = this._urls[url].length;
					if (urlLength > 1) {
						var newIndex = this._urls[url][((++item.indexCounter) % urlLength)];
						this.selectedIndex = newIndex;
						//item.indexCounter = item.indexCounter % urlLength;
					} else {
						this.selectedIndex = item.index;
					}

					if (!this.isRemoved) {
						item.invokeRequest(context);
					}

				},
				exitingItemRoute: function (context, item, ignoreSameUrl) {
					console.log("exiting route");
				},
				attached: function () {
					this.addEventListener("child-ready", this.debouncedUpdate, true);
					this.addEventListener("child-removed", this.debouncedUpdate, true);
					this.debouncedUpdate();
				},
				debouncedUpdate: function () {
					this.cancelDebouncer("DEBOUNCE-UPDATE-ITEMS");
					this.debounce("DEBOUNCE-UPDATE-ITEMS", function () {
						this.update();

						var urlFound = false;
						for (var i = 0; i < this.items.length; ++i) {
							var item = this.items[i];
							var url = item.getAttribute("url");
							var ctx = this.isUrlMatching(url);
							if (ctx) {
								this.urlChanged(ctx, item, true);
								urlFound = true;
								break;
							}
						}

						if (!urlFound) {
							this.indexChanged(this.selectedIndex);
						}

						this.updateSize(this.items[this.selectedIndex]);
					}, 5);
				},
				detached: function () {
					this.items = [];
					this.routeContext = null;
					this.removeAllroutes();
				},
				indexChanged: function (newValue, oldValue) {
					if (!this.items || this.items.length === 0) {
						return;
					}

					var newItem = this.items[newValue];

					if (newValue < 0 || newValue > this.items.length - 1) {
						this.selectedIndex = oldValue;
						console.warn("the selectedIndex: " + newValue + " is out of range!");
						return;
					}

					var self = this;
					if (newItem.tagName.toLowerCase() === "element-loader" && !newItem.loadedElement) {
						newItem.on(newItem, Event.ELEMENT_LOADED, function (e) {
							if (newItem === self.items[self.selectedIndex]) {
								self.indexChanged.call(self, newValue);
							}
						});
						this._itemIsLoading = true;
						this.debounce('ADD_PRELOADER', function () {
							this.classList.add("preloading");
						}, 1500);
						newItem.load();
					} else {
						this._itemIsLoading = false;
						this.cancelDebouncer('ADD_PRELOADER');
						this.classList.remove("preloading");
					}

					newItem.style.display = "block";

					if (this._showEffect && !this._itemIsLoading) {
						this._showEffect.kill();
					}

					if (typeof oldValue === "number") {
						var oldItem = this.items[oldValue];
						self.preHidden.call(self, oldItem);
						if (!this._itemIsLoading) {
							self.preShown.call(self, newItem);
						}
						if (this._hideEffect) {
							this._hideEffect.start(oldItem, this,
									function (e) {
										self.startHiding.call(self, oldItem);
									},
									null,
									function (e) {
										self.hidden.call(self, oldItem);
									});
						} else {
							self.startHiding.call(self, oldItem);
							self.hidden.call(self, oldItem);
						}
					} else {
						if (!this._itemIsLoading) {
							this.preShown(newItem);
						}
						//this.updateSize(newItem);
					}

					if (!this._itemIsLoading) {
						if (this._showEffect) {
							this._showEffect.start(newItem, this,
									function (e) {
										self.startShowing.call(self, newItem);
									},
									null,
									function (e) {
										self.shown.call(self, newItem);
									});
						} else {
							self.startShowing.call(self, newItem);
							self.shown.call(self, newItem);
							//self.updateSize(newItem);
						}

						this._lastSelectedIndex = oldValue;
						var lastSelected = this.items[oldValue];
						var newSelected = this.items[newValue];

						if (lastSelected) {
							lastSelected.classList.remove("selected");
							if (lastSelected.classList.length === 0) {
								lastSelected.removeAttribute("class");
							}
						}

						if (newSelected) {
							newSelected.classList.add("selected");
						}
					}
				},
				updateSize: function (item, skipAnimation) {
					if (this.resizeToContent && item) {
						this.debounce("RESIZE-ITEM", function () {
							if (skipAnimation) {
								TweenMax.set(this, {width: item.offsetWidth, height: item.offsetHeight});
							} else {
								var self = this;
								TweenMax.to(this, .4, {width: item.offsetWidth, height: item.offsetHeight, onComplete: function () {
										var cr = self.routeContext && self.routeContext.currentRoute && self.routeContext.currentRoute.context;
										if (cr && cr.direction === 0) {
											self.scrollToAnchor();
										}
									}
								});
							}
						}, 2);
					}
				},
				preShown: function (item) {
					item.style.display = "initial";
					this.callLifecycleFunctions(item, "preShown");
					var cr = this.routeContext && this.routeContext.currentRoute && this.routeContext.currentRoute.context;
					if (cr && cr.direction !== 0) {
						this.updateSize(item, true);
					}
				},
				startShowing: function (item) {
					this.callLifecycleFunctions(item, "startShowing");
				},
				shown: function (item) {
					this.callLifecycleFunctions(item, "shown");
					this.updateSize(item);
//					this.scrollToAnchor();
				},
				preHidden: function (item) {
//					item.style.position = "absolute";
					this.debounce('PRE-HIDDEN', function () {
						this.callLifecycleFunctions(item, "preHidden");
					}, 1);
				},
				startHiding: function (item) {
					this.callLifecycleFunctions(item, "startHiding");
				},
				hidden: function (item) {
					item.style.display = "none";
					this.callLifecycleFunctions(item, "hidden");
				},
				callLifecycleFunctions: function (item, func) {
					if (item.tagName.toLowerCase() === "element-loader") {
						if (!item.loadedElement) {
							if (func === "startShowing") {
								item.load();
								var self = this;
								this.onMessage({
									channel: Channel.ELEMENT_LOADED,
									route: item.url,
									callback: function (e) {
										e.routeContext = self.routeContext;
									}
								});
							}

							if (item.transitionCallbacks && item.transitionCallbacks.push) {
								item.transitionCallbacks.push(func);
							}
						}

						item = item.loadedElement || item;
					}
					if (typeof item[func] === "function") {
						var route = item.getAttribute("route") || location.href;
						var rt = Route[route.replace("Route.", "")] || Route[route] || _routes[route];
						var obj = {item: item, routeContext: this.routeContext, phase: func};
						this.sendMessage({
							channel: Channel.TRANSITION_LIFECYCLE,
							route: rt,
							context: obj
						});

						item[func].call(obj.item, obj.routeContext);
					}
				}

			});

		})(window, window.polyflex.Channel);
	</script>
</dom-module>
