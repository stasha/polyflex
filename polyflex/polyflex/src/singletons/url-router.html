<link rel="import" href="../behaviors/CoreBehavior.html" />
<link rel="import" href="../behaviors/EventBehavior.html" />
<link rel="import" href="../behaviors/RoutingBehavior.html" />

<dom-module id="url-router">

	<script>
		(function (window, Channel) {

			"use strict";

			var polyflex = window.polyflex = window.polyflex || {};
			var behaviors = polyflex.behaviors = polyflex.behaviors || {};
			var Route = polyflex.Route;
			var Event = polyflex.Event;
			var routes = polyflex.routes;
			var _routes = polyflex._routes;
			var routeNames = polyflex.routeNames;

			var page = window.page;


			Polymer({
				is: "url-router",
				behaviors: [behaviors.CoreBehavior, behaviors.EventBehavior, behaviors.RoutingBehavior],
				currentRoute: null,
				lastRoute: null,
				bodyClicked: false,
				urlHistory: [],
				historyPosition: 0,
				backButtonMarker: "/__b__",
				properties: {
					base: {
						type: String,
						observer: "setBase"
					}
				},
				setBase: function (newValue) {
					if (newValue) {
						page.base(newValue);
						this.log("Setting base url to: " + newValue);
					}
				},
				created: function () {
					page.ignorePatterns = [this.backButtonMarker];
					this.onMessage({
						channel: Channel.ROUTE_ENTER,
						route: Route.ROUTE_NOT_FOUND,
						callback: function (context) {
							console.log("no route found");
						}
					});
					this.addRoute(Route.ROUTE_NOT_FOUND);
					var self = this;
					this.on(document.querySelector("body"), Event.CLICK, function (e) {
						self.bodyClicked = true;
						self.debounce("CLEAR-BODY-CLICK", function () {
							self.bodyClicked = false;
						}, 10);
					});
				},
				detached: function () {
					page.stop();
					this.log("Router stopped.");
				},
				addRoute: function (route) {
					if (!route) {
						throw "You cant add route: " + route;
					}

					var rt = Route[route.replace("Route.", "")] || Route[route] || _routes[route];

					if (!rt) {
						throw "Please register route \"" + route + "\" before using it.";
					}

					var self = this;

					// Route can be registered with the router only once.
					// Once the route is registered, there is no back, 
					// at least for now.
					for (var i = 0; i < page.callbacks.length; ++i) {
						var routeObj = page.callbacks[i];
						if (routeObj.path === rt) {
							return;
						}
					}

					var addBackButtonMarker = function (url) {
						var sbm = self.backButtonMarker;
						if (url.indexOf(sbm) === -1) {
							//var u = url.indexOf("#") > -1 ? url + sbm : url + "#" + sbm;
							page.replace(url + sbm, null, null, false);
						}
					};

					var removeBackButtonMarker = function (url) {
						var sbm = self.backButtonMarker;
						var nsbm = "#" + sbm;
						if (url.indexOf(sbm) > -1) {
							var u = url.replace(nsbm, "").replace(sbm, "");
							page.replace(u, null, null, false);
						}
					};

					var findHistoryEntry = function (url) {
						var loc = window.location.href.replace(self.backButtonMarker);
						var idx = loc.indexOf(url);
						if (idx > -1) {
							url = loc.substr(idx);
						}
						for (var i = 0; i < self.urlHistory.length; ++i) {
							if (self.urlHistory[i] === url) {
								return i;
							}
						}
						return -1;
					};



					var calculateNavigation = function (currentRoute, lastRoute) {
						if (!self.bodyClicked) {
							var historyIndex = findHistoryEntry(currentRoute.context.canonicalPath);
							if (currentRoute.context.canonicalPath.indexOf(self.backButtonMarker) === -1 && historyIndex !== self.urlHistory.length - 1) {
								addBackButtonMarker(currentRoute.context.path);
								return -1;
							} else if (currentRoute.context.canonicalPath.indexOf(self.backButtonMarker) > -1 || historyIndex === self.urlHistory.length - 1) {
								removeBackButtonMarker(currentRoute.context.path);
								return 1;
							}
						}
					};

					/**
					 * Registering route with url router.
					 * 
					 * @param {type} ctx
					 * @returns {undefined}
					 */
					page(rt, function (ctx) {

						var newRoute = extend(true, {}, routes[routeNames[rt]]);
						newRoute.pattern = rt;
						newRoute.context = ctx;


						// if currentRoute is set than we process it as old route
						if (self.lastRoute) {

							// Send message that route is changed/exited.
							// Note that "route-exited" message is sent before
							// "route-entered" message.
							self.currentRoute.windowScrollPosition = self.windowScrollPosition();

							if (calculateNavigation(newRoute, self.lastRoute) === -1) {
								// sends message that route is changed using back button.
								self.sendMessage({
									channel: Channel.BROWSER_BACK,
									route: route,
									context: {currentRoute: newRoute, lastRoute: self.lastRoute}
								});
							}


							self.sendMessage({
								channel: Channel.ROUTE_EXIT,
								route: self.lastRoute,
								context: {currentRoute: newRoute, lastRoute: self.lastRoute}
							});
						}


						self.currentRoute = newRoute;

						// if navigation occured without click on body than we 
						// asume that url navigation occured using browsers 
						// back/forward buttons.
						if (!self.bodyClicked) {
							var scrp = self.currentRoute.windowScrollPosition || {x: 0, y: 0};
							self.windowScrollPosition.call(self, {x: scrp.x, y: scrp.y});
							self.log("Scrolling window to position: x=" + scrp.x + ", y=" + scrp.y);

							if (calculateNavigation(self.currentRoute, self.lastRoute) === 1) {
								// sends message that route is changed using forward button.
								self.sendMessage({
									channel: Channel.BROWSER_FORWARD,
									route: route,
									context: {currentRoute: newRoute, lastRoute: self.lastRoute}
								});
							}

						} else {
							// storing/removing urls in/from local history so we later can
							// calculate if browser is going forward or back.
							var historyIndex = findHistoryEntry(self.currentRoute.context.canonicalPath);
							if (historyIndex > -1) {
								self.urlHistory = self.urlHistory.splice(historyIndex, 1);
							}

							self.urlHistory.push(ctx.canonicalPath);
						}


						document.querySelector("title").innerHTML = self.currentRoute.title || "";

						// sends message that route is changed/entered.
						self.sendMessage({
							channel: Channel.ROUTE_ENTER,
							route: route,
							context: {currentRoute: self.currentRoute, lastRoute: self.lastRoute}
						});


						// changing from old route to new route
						self.lastRoute = self.currentRoute;
					});

					/**
					 * Registering route with url router.
					 * 
					 * @param {type} ctx
					 * @returns {undefined}
					 */
//					page.exit(rt, function (ctx) {
//						// Send message that route is changed/exiting.
//						// Note that "route-exited" message is sent before
//						// "route-entered" message.
//						self.sendMessage({
//							channel: Channel.ROUTE_EXIT,
//							route: route,
//							context: {context: ctx}
//						});
//					});

					page.start({dispatch: false});

				},
				componentsReady: function () {
					this.webComponentsReady = true;
					page.start();
				}
			});

		})(window, window.polyflex.Channel);
	</script>
</dom-module>