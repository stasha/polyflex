<link rel="import" href="../behaviors/CoreBehavior.html" />
<link rel="import" href="../behaviors/EventBehavior.html" />
<link rel="import" href="../behaviors/RoutingBehavior.html" />

<dom-module id="url-router">

	<script>
		(function (window, Channel) {

			"use strict";

			var polyflex = window.polyflex = window.polyflex || {};
			var behaviors = polyflex.behaviors = polyflex.behaviors || {};
			var Route = polyflex.Route;
			var Event = polyflex.Event;
			var routes = polyflex.routes;
			var _routes = polyflex._routes;
			var routeNames = polyflex.routeNames;

			var page = window.page;


			Polymer({
				is: "url-router",
				behaviors: [behaviors.CoreBehavior, behaviors.EventBehavior, behaviors.RoutingBehavior],
				currentRoute: null,
				lastRoute: null,
				currentUid: 0,
				properties: {
					baseUrl: {
						type: String,
						observer: "setBase"
					},
					enableBackForwardScrollToAnimation: {
						type: Boolean,
						value: false
					},
					backForwardAnimationSpeed: {
						type: Number,
						value: .3
					},
					backForwardAnimationDelay: {
						type: Number,
						value: 1000
					}
				},
				setBase: function (newValue) {
					if (newValue) {
						page.base(newValue);
						this.log("Setting base url to: " + newValue);
					}
				},
				created: function () {
					var self = this;

					// Registering message listener that will be invoked
					// if no route is found (404).
					this.onMessage({
						channel: Channel.ROUTE_ENTER,
						route: Route.ROUTE_NOT_FOUND,
						callback: function (context) {
							console.log("no route found");
						}
					});

					// Registering route not found
					this.addRoute(Route.ROUTE_NOT_FOUND);

					var cv = document.querySelector(".body");
					var cvs = this.body.currentStyle || window.getComputedStyle(this.body);

					window.addEventListener("hashchange", function () {
						console.log("hashchanged");
					});
					window.addEventListener('popstate', function (e) {
						if (!self.enableBackForwardScrollToAnimation) {
							self.skipScrollToAnimation = true;
							// triggers scroll end if scrollToEffect is disabled.
							self.debounce('WINDOW-SCROLL-END', function () {
								//self.trigger("window", new CustomEvent(Event.SCROLL_END, {detail: obj}));
							}, 2);
							return;
						}

						self.lastScrollPosition = e.state.scrollPosition;
						self.disableBodyScroll();

						self.debounce('SCROLL-TO', function () {
							self.scrollFromPopState = true;

							var wp = window.scrollPosition;
							var obj = e.state.scrollPosition;


							if (!window.scrollToEffect || !window.scrollToEffect.isActive()) {
								TweenMax.set(cv, {scrollTo: {x: wp.x, y: wp.y}});
							}
//						window.scrollToEffect && window.scrollToEffect.kill();
							window.scrollToEffect = TweenMax.to(cv, self.backForwardAnimationSpeed, {scrollTo: {x: obj.x, y: obj.y, autoKill: true}, ease: Power2.easeOut, onComplete: function () {
									self.debounce("ENABLE-BODY-SCROLL", function () {
										self.scrollFromPopState = false;
										self.saveScrollPosition();
										self.enableBodyScroll();
									}, 2);
									//self.trigger("window", new CustomEvent(Event.SCROLL_END, {detail: obj}));
								}
							});

						}, self.backForwardAnimationDelay);
					});



					self.saveScrollPosition = function () {
						self.debounce("SAVE-SCROLL-POSITION-IN-STATE", function () {
							if (self.currentRoute && !self.scrollFromPopState) {
								self.currentRoute.context.state.scrollPosition = window.scrollPosition = self.windowScrollPosition;
								self.currentRoute.context.save();
							}
							self.scrollFromPopState = false;
						}, 200);
					};

					// Saving pages scroll position in state object.
					window.addEventListener(Event.SCROLL, self.saveScrollPosition);
					//cv.addEventListener(Event.SCROLL, self.saveScrollPosition);



					self.enableBodyScroll = function (e) {
						self.body.classList.remove("non-scrollable-viewport");
						var pos = {x: cv.scrollLeft, y: cv.scrollTop};
						cv.classList.remove("scrollable-viewport");
						TweenMax.set(window, {scrollTo: {x: pos.x, y: pos.y}});
						self.bodyIsScrolling = true;
					};

					self.disableBodyScroll = function (e) {
						if (self.body.className.indexOf("non-scrollable-viewport") === -1) {
							self.scrollFromPopState = true;
							var pos = self.lastScrollPosition = window.scrollPosition;
							self.body.classList.add("non-scrollable-viewport");
							cv.classList.add("scrollable-viewport");
							TweenMax.set(cv, {scrollTo: {x: pos.x, y: pos.y}});
							self.bodyIsScrolling = false;
						}
					};



				},
				detached: function () {
					page.stop();
					this.log("Router stopped.");
				},
				addRoute: function (route) {
					if (!route) {
						throw "You cant add route: " + route;
					}

					var rt = Route[route.replace("Route.", "")] || Route[route] || _routes[route];

					if (!rt) {
						throw "Please register route \"" + route + "\" before using it.";
					}

					var self = this;

					// Route can be registered with the router only once.
					// Once the route is registered, there is no back, 
					// at least for now.
					for (var i = 0; i < page.callbacks.length; ++i) {
						var routeObj = page.callbacks[i];
						if (routeObj.path === rt) {
							return;
						}
					}

					/**
					 * Returns where browser navigation direction.
					 * -1 - back button was clicked
					 *  1 - forward button was clicked
					 *  0 - normal navigation occured
					 * 
					 * @param {type} currentRoute
					 * @param {type} lastRoute
					 * @returns {Number}
					 */
					var evaluateNavigationDirection = function (currentRoute, lastRoute) {
						if (lastRoute) {
							var newUid = currentRoute.context.state.uid || page.uid;
							var oldUid = lastRoute.context.state.uid || page.uid;
							if (newUid < (self.currentUid || page.uid)) {
								self.currentUid = newUid;
								return -1;
							} else if (self.currentUid && newUid > self.currentUid) {
								self.currentUid = newUid;
								if (page.uid - 1 === oldUid) {
									self.currentUid = null;
								}
								return 1;
							}
						}

						self.currentUid = null;
						return 0;
					};

					/**
					 * Registering route with url router.
					 * 
					 * @param {type} ctx
					 * @returns {undefined}
					 */
					page(rt, function (ctx) {

						var newRoute = extend(true, {}, routes[routeNames[rt]]);
						newRoute.pattern = rt;
						newRoute.context = ctx;

						var direction = evaluateNavigationDirection(newRoute, self.lastRoute);

						// if forward button was clicked than we send event
						if (direction === -1) {
							// sends message that route is changed using back button.
							self.sendMessage({
								channel: Channel.BROWSER_BACK,
								route: route,
								context: {currentRoute: newRoute, lastRoute: self.lastRoute}
							});
						} else if (direction === 1) {
							self.sendMessage({
								channel: Channel.BROWSER_FORWARD,
								route: route,
								context: {currentRoute: newRoute, lastRoute: self.lastRoute}
							});
						}

						if (self.lastRoute) {

							// Send message that route is changed/exited.
							// Note that "route-exited" message is sent before
							// "route-entered" message.
							self.sendMessage({
								channel: Channel.ROUTE_EXIT,
								route: self.lastRoute,
								context: {currentRoute: newRoute, lastRoute: self.lastRoute}
							});
						}


						self.currentRoute = newRoute;

						// setting window scroll position
						var scrp = self.currentRoute.context.state.scrollPosition || {x: 0, y: 0};
						
						self.windowScrollPosition = {x: scrp.x, y: scrp.y};
						self.log("Scrolling window to position: x=" + scrp.x + ", y=" + scrp.y);


						document.querySelector("title").innerHTML = self.currentRoute.title || "";

						// sends message that route is changed/entered.
						self.sendMessage({
							channel: Channel.ROUTE_ENTER,
							route: route,
							context: {currentRoute: self.currentRoute, lastRoute: self.lastRoute}
						});


						// changing from old route to new route
						self.lastRoute = self.currentRoute;
					});

					page.start({dispatch: false});

				},
				componentsReady: function () {
					this.webComponentsReady = true;
					page.start();
				}
			});

		})(window, window.polyflex.Channel);
	</script>
</dom-module>